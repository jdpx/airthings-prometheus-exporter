/*
Airthings for Consumer API

The Airthings for Consumer API provides secure and authorized access for Airthings consumers to retrieve the latest data from their Airthings air quality monitors. Leveraging HTTPS and OAuth for enhanced security, this API empowers users to seamlessly access real-time information from their Airthings devices, gaining valuable insights into the air quality within their environments.

API version: 1.0.0
Contact: support@airthings.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package airthings

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SensorAPIService SensorAPI service
type SensorAPIService service

type ApiGetMultipleSensorsRequest struct {
	ctx context.Context
	ApiService *SensorAPIService
	accountId string
	sn *[]string
	pageNumber *int32
	unit *string
}

// The serial numbers of the devices
func (r ApiGetMultipleSensorsRequest) Sn(sn []string) ApiGetMultipleSensorsRequest {
	r.sn = &sn
	return r
}

// The number of a page (of 50 records) to fetch
func (r ApiGetMultipleSensorsRequest) PageNumber(pageNumber int32) ApiGetMultipleSensorsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The units type sensors values will be returned in
func (r ApiGetMultipleSensorsRequest) Unit(unit string) ApiGetMultipleSensorsRequest {
	r.unit = &unit
	return r
}

func (r ApiGetMultipleSensorsRequest) Execute() (*GetMultipleSensors200Response, *http.Response, error) {
	return r.ApiService.GetMultipleSensorsExecute(r)
}

/*
GetMultipleSensors Get sensors for a set of devices

Get sensors for a set of devices. The response will contain the latest sensor values for the devices.
The sensor values are updated depending on the device types sampling rate.
It is recommended to poll the API at a regular interval to get the latest sensor values.
The response will be paginated with a maximum of 50 records per page.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account ID associated with the user
 @return ApiGetMultipleSensorsRequest
*/
func (a *SensorAPIService) GetMultipleSensors(ctx context.Context, accountId string) ApiGetMultipleSensorsRequest {
	return ApiGetMultipleSensorsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GetMultipleSensors200Response
func (a *SensorAPIService) GetMultipleSensorsExecute(r ApiGetMultipleSensorsRequest) (*GetMultipleSensors200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMultipleSensors200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SensorAPIService.GetMultipleSensors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/accounts/{accountId}/sensors"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sn != nil {
		t := *r.sn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sn", t, "form", "multi")
		}
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "form", "")
	} else {
		var defaultValue string = "metric"
		r.unit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
